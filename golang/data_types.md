## Data types

Вопрос:
Почему размер логического типа данных (BOOL) 1 байт, а не один бит ?
Ответ:
большинство современных процессоров могут адресовать память только по байтам, а не по отдельным битам. Операции с отдельными битами требуют дополнительных вычислений (маскирование, сдвиги), что замедляет работу.


Вопрос:
Что произойдет, если мы запишем в число больше информаций, чем она может вместить
Ответ:
Для беззнаковых типов (например, uint8): значение "обернётся" по модулю максимального значения типа. Например, uint8(256) == 0.
Для знаковых типов (например, int8): произойдет аналогичное переполнение, но с учетом знака. Например, int8(128) == -128.

Вопрос:
Как проверить переполнения чисел  (int overflow detection) ?
Ответ 
```golang
var ErrIntOverflow = errors.New("integers overflow")

func Increment(counter int) (int, error) {
	if counter == math.MaxInt {
		return 0, ErrIntOverflow
	}

	return counter + 1, nil
}

func Add(left, right int) (int, error) {
	if left > 0 && right > math.MaxInt-left {
		return 0, ErrIntOverflow
	}
	if left < 0 && right < math.MaxInt-left {
		return 0, ErrIntOverflow
	}

	return left + right, nil
}

func Multiply(left, right int) (int, error) {
	if left == 0 || right == 0 {
		return 0, nil
	}

	if left > 0 && right > math.MaxInt/left {
		return 0, ErrIntOverflow
	}
	if left < 0 && right < math.MaxInt/left {
		return 0, ErrIntOverflow
	}

	return left * right, nil
}
```
Примечание:
В Go 1.21+ появились функции из пакета math/bits для безопасных операций с переполнением, например, bits.Add64, которые возвращают флаг переполнения.

Вопрос:
Расскажите об `uintptr`
Ответ:
`uintptr` в Go — это целочисленный тип без знака, который достаточно велик, чтобы вместить указатель любого типа.
Важно, `uintptr` не гарантирует, что значение будет оставаться валидным указателем после преобразования обратно, и не предотвращает сборку мусора для объекта по этому адресу. Использовать его следует только для специальных задач, когда обычные указатели не подходят.

Вопрос:
Как сделать массив, мар, структуру иммутабильной ?
Ответ:
Никак! Их константами сделать нельзя. Они в го всегда мутабельны.
Место этого используеться инкапсуляция (коструктор или приватные поля в структуре + getters)