Вопрос:
Где алоссируеться массив ?
Ответ:
В Go массив аллоцируется (выделяется в памяти) там, где он объявлен:
**На стеке** — если массив объявлен как локальная переменная фиксированного размера внутри функции и не передаётся по ссылке, он обычно размещается на стеке.
**В куче (heap)** — если массив создаётся с помощью new, make, или возвращается из функции (или используется как часть структуры, которая аллоцируется в куче), он размещается в куче.
Go автоматически определяет, где разместить массив, с помощью escape-анализа. Если массив "уходит" за пределы функции (например, возвращается из неё), он будет размещён в куче. Если используется только внутри функции, — на стеке.

Вопрос:
Почему в io.Reader такая сигнатура ?
```golang
func (T) Read(b []byte ) (n int err error)
```
А не такая ?
```golang
func (T) Read(n int ) (b []byte err error)
```
Ответ:
1. Избежание лишних аллокаций:
Вы сами выделяете буфер b, и функция заполняет его данными. Это позволяет переиспользовать один и тот же буфер, не создавая новые срезы при каждом чтении, что экономит память и ускоряет работу.
2. Гибкость:
Вы контролируете размер буфера и можете читать ровно столько данных, сколько хотите за раз.
3. Совместимость с потоками:
В потоковых интерфейсах (например, файлы, сети) невозможно заранее узнать, сколько данных будет доступно. Поэтому функция возвращает количество реально прочитанных байт (n), а не всегда весь буфер.